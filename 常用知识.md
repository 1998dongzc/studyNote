# 常用知识

### 1.IO

IO流程为：应用程序向系统内核发起系统调用，内核程序接受调用，向磁盘读取数据，等待数据读取就绪，然后将内核程序将数据从内核缓存区拷贝到应用程序数据缓存区，应用程序从程序缓存区读取数据。

---

1. BIO 同步阻塞IO

```
应用程序发起系统调用后，一直阻塞到应用程序读取到数据

简化：应用在数据读取完之前，没法干其他事情
```

2. NIO 同步非阻塞IO

```
应用程序发起系统调用后，内核立即返回状态，但数据还在内核中读取，应用程序通过不停的read来判断是否能读取到数据，内核数据加载完成之前一直循环read，直到应用程序read到数据。（多IO操作是，会进行轮询read系统调用判断），高并发时，会有很多无效的read系统调用，性能浪费

简化：后台同时进行多个通道进行数据读取，期间应用程序可以干其他事情，但其间会定期轮询遍历每个数据IO，查询到内核读取完成后，应用程序开始read
```

3. NIO 多路复用（多路复用 这个名字带有一定的迷惑性 翻译的问题 容易误导）

   理解连接 https://baijiahao.baidu.com/s?id=1611547498841608701&wfr=spider&for=pc

```
在同步非阻塞的基础上，通过一个线程（select、poll、epoll）来进行系统调用（判断状态），线程一次操作选择多个读取，来判断内核读取数据的状态，随后让应用程序进行read系统调用，读取数据。
select线程抓取有数量限制，最多1024
poll没有数量限制
epoll比select、poll多了两次系统调用，优化了IO效率，epoll没有数量限制，也不像前两者遍历所有通道，而是判断状态活跃的IO流。

简化：后台同时进行多个通道进行数据读取，期间应用程序可以干其他事情，通过select、poll、epoll一次调用直接访问多个通道，判断内核读取完成后，应用程序开始read
```

4. AIO 异步IO

```
异步IO，应用程序发送系统调用后，立马返回，不会堵塞，内核读取数据完成后，系统发送通知，让对应应用线程读取数据，不会造成任何堵塞

简化：后台进行数据读取，期间应用程序可以干其他事情，内核读取完成后，系统发送通知给应用程序，应用再去read数据
```

IO对比图

![img](https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png)

### 2.代理

白话：以代理对象来代替原来的对象向目标对象，完成原始的任务后，还能扩展完成一些其他额外的任务。

----

1. 静态代理

```
原对象的增强任务需要手动增加（将方法写死）
```

